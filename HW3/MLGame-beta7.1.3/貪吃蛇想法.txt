最一開始最簡單的想法當然就是當snake_head的x小於food的x就讓蛇往右，其他三個方向也是一樣作法，也就是完全不考慮會死亡的情況，直接讓蛇往食物奔去，雖然這樣可以確保蛇一定是循著最短路徑去吃食物，但是死亡率極高，因為完全沒考慮到會碰到蛇身或是可能會繞一圈把自己困住等等的情況，唯一考慮的只有不會撞到牆壁。

後來就上網找了相關的貪吃蛇AI想法，關於貪吃蛇要如何尋找到最短路徑並且不會死亡，其實要拆開分成兩部分來討論，也就是(1)如何讓蛇找到往食物的最短路徑、還有(2)如何確保蛇無論如何都不會死亡。

先討論(1)，也就是貪吃蛇AI最核心的問題，如何讓蛇可以找到通往食物的最短路徑，當然最一開始的那個簡單想法也是一種，但是也很容易會讓蛇直接死掉，因此在這邊討論的除了是通往食物的最短路徑外，同時這條路徑也要是讓蛇可以完整吃到食物並且在路上不會死亡的，當然有可能吃完食物以後發現自己被困住了沒辦法出來，這個部份我保留到討論(2)的時候。

網路上有很多種用來使用在遊戲上尋找最短路徑的演算法，而我找到的比較常用在貪吃蛇上的有兩種，一種是BFS(廣度優先搜尋)、另一種是A*(A star)。這兩種做法都能夠確保蛇可以找到往食物的最短路徑，同時因為我們在進行這兩種演算法時都會將蛇身當作障礙物考慮進去，因此可以保證在通往食物的路上，蛇不會因為碰到自己的身體而死亡。

但是這邊還會遇到兩個問題，第一個問題就是我們需要在每次執行演算法時都重新更新一次地圖，原因是蛇的身體也會動，意味著我們所謂的障礙物的位置會變化，因此需要每次更新地圖，才能讓蛇做到不會死。第二個問題在於蛇有可能會在某種情況變成為了不會死而瘋狂繞圈圈(這個我沒想到要如何解決，有想過可以讓他隨便動一步來跳出死胡同，但不確定要在什麼條件下讓他成立...)。

再來就是討論(2)的部分，因為貪吃蛇有可能會在吃完食物後陷入死胡同，而蛇不會死的方法在於"可以找到通往自己尾巴的路徑"(因為蛇一直追著自己的尾巴就不會死)，因此在要去吃食物之前，我先派一條假蛇去吃，如果假蛇吃完後可以找到往自己尾巴的路徑，表示蛇吃完以後可以是安全的，真蛇再移動去吃就行了，而如果甲蛇吃完會死，我就讓真蛇往自己的尾巴最短路徑移動一步，用這個方法來改變通往食物的最短路徑，如此就可以找到最佳解了。

但說了這麼多也有了想法，到後來我因為沒辦法寫出上面繁瑣的演算法，於是我放棄了上面的作法...我選擇退而求其次，雖然我沒辦法確保我的蛇用最快的速度去吃到食物，但助教有說不會限制蛇移動的時間，因此我最終採取的作法是選擇讓蛇一直上下繞、從右邊跑到左邊，然後把整個地圖掃過，如此一來我的蛇可以永遠不會死，只是相對地吃到食物的時間會長很多，有可能繞了一整張地圖只吃到一次食物。

於是我想我雖然寫不出很厲害的作法，但我至少可以在我這個退而求其次的辦法上尋求一點讓速度變快的變化，於是我第一個想到的是，當我的蛇吃到食物後，如果食物出現在蛇的右邊，我就直接讓蛇跑道最右邊讓蛇重新掃過整張地圖，如此一來，雖然只是小小的改變也讓我的速度快了許多。

我覺得還是可以再做變化，於是我想到，當食物出現在蛇的右邊時我可以不要又跑整圈，直接讓蛇從食物的x座標開始重新繞圈就好了，但這會有個小問題是，因為我讓蛇繞圈圈時有留一個小通道在最下面，確保蛇不會死，但是如果我隨便繞上來吃食物，有可能我跑到最左邊時發現我的蛇是往上走的，但我沒有留通道在上面所以蛇會死掉，於是在這邊需要加上一個條件，就是如果蛇繞回去吃食物時，到最後面的時候可以往下走，那我就直接往上去吃食物，但如果到最後面會變成是往上走的話，那當我蛇往回繞時，我就多往右邊走一步再往上繞去吃食物，用這個方法來改變蛇上下繞的方向，確保蛇在最後繞到最左邊時是往下走的。

目前能想到的我能做出來的最佳解法大概就是如此，在這種方法之下，只要不要突然delay frame，通常都能到達300以上的分數(那是當然，畢竟只是在繞來繞去...而且如果用60fps跑差不多要跑個45分鐘以上...)。